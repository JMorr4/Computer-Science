# Data Structures

## Arrays, Lists and Tuples

### Arrays
- An **array** is an ordered set of values of the same type.
- A 1D array is a linear array.
- A 2D array can be visualised as a table, with rows and columns.
- A 3D array can be visualised as a multi-page spreadsheet
  - An element in a 3D array is created using: threeDimensionalArray[z,y,x], where z = array number, y = row number, x = column number.

### Lists
- A **list** is an ordered set of values of potentially different data types, where the same items can appear more than once.
- Data from this list can be stored in non-contiguous locations.

### Tuples
- An ordered set of values of any data type .
- Cannot be changed: elements cannot be added, edited or removed once initialised.
- Initialised with regular brackets rather than square brackets

<br>

## Linked Lists, Graphs, Stacks, Queues, and Trees

### Linked Lists
- Dynamic data structure used to hold an ordered sequence
- Items do not have to be in contiguous data locations
- Each item is called a node, and contains a data field and a link or pointer field.
- Data field: contains the actual data associated with the list
- Pointer field: contains the address of the next item in the list

### Graphs
- Set of vertices/nodes connected by edges/arcs. ,
  - Directed Graph: Edges can only be traversed in one direction
  - Undirected Graph:Edges can be traversed in both directions,
  - Weighted Graph: Each arc has a cost attached to it
- Implemented using an adjacency matrix or an adjacency list.

### Stacks
- Last in first out (LIFO) data structure:
  - Items can only be added to/ removed from the top of the stack.
  - Used to reverse actions, eg. back buttons and undo buttons use stacks
  - Can be implemented as a static or dynamic structure.

### Queues
- First in first out (FIFO) data structure:
  - Items are added to the end and are removed from the front of the queue.
- Used in printers, keyboards and simulators.
- Linear queue: items are added into the next available space, starting from the front.
  - Items are removed from the front of the queue
  - Uses two pointers: pointing to the front and back of the queue.
  - Use space inefficiently, as positions from which data has been removed cannot be reused
- Circular queues have a rear pointer that can loop back to the front of the queue andutilise empty space at the front.
  - Are harder to implement
