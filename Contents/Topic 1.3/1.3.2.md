# Databases

## Relational Databases

<img src="https://user-images.githubusercontent.com/90699946/167940455-1516ea5b-eae4-45c8-8de8-c352b331aa32.png" align="right" width="250px"/>

- An **entity** is an object that exists in real life.
- An **attribute** are the characteristics of an entity.
- A **relational database** creates different tables for each entity, linked together by a shared attribute.
- Relational databases are more efficient than flat-file databases because:
    - They take up less space and memory
    - They have reduced chance of **data redundancy**, meaning a lesser chance of data being partially duplicated across         records

<br clear="right"/>

## Flat File Databases

### Flat File

<img src="https://user-images.githubusercontent.com/90699946/168394778-fe7d8275-2e30-46ac-8cff-1b351bc00cc4.png" align="right" width="350px"/>

- A **flat file database** is a database with a single table. It will most likely be based around a single entity and its attributes.
- A **field** is a column in a database table, and a **record** is a row.

### Keys

<img src="https://user-images.githubusercontent.com/90699946/168123876-42f14166-6493-465f-8bc4-6175d54c4bdb.png" align="right"/>

- A **primary key** is a unique identifier for each **record** in the table. In *Student* table, this is the field *ID No.*
- A **foreign key** is the attribute that links two tables together. It exists in one table as the primary key and act as the foreign key in another. For example, *Class* is a **primary** key in *Class* table, and a **foreign** key in *Student* table.
- A **secondary key** allows a database to be searched quickly. For example, it is unlikely for a student to remember their student ID, so a secondary key can be set up on *Name* instead, even though it is less unique, a student can easily filter for their details by inputting their name.

<br clear="right"/>

## Entity Relationship Modelling
When creating a relationship between two entities, there are different types of relationship models:
- **One-to-one**: Each entity can only be linked to one other entity, **e.g.** A husband and wife.
- **One-to-many**: A single entity can be linked to many entities, **e.g.** A doctor and his patients.
- **Many-to-many**: Several entities can be interconnected with each other, **e.g.** Students and classes, where different customers can purchase different products.

Each relationship type is represented differently:

<img src="https://user-images.githubusercontent.com/90699946/168450921-aea1952f-7474-4a42-b082-52455fee8300.png" align="right" width="250px"/>

- **One-to-one**: A single line between two entities.
- **One-to-many**: A line with a branch on the **many** side.
- **Many-to-many**: A line with a branch on both sides.

<br clear="right"/>

## Handling Data

### Capturing Data
There are multiple ways of inputting data into a database:
- Manual Input
- Smart card readers
- Barcode readers
- Scanners
- Optical character recognition (OCR)
- Optical mark recognition (OMR)
- Magnetic Ink Character Recognition
- Sensors

### Selecting and Managing Data
Selecting the correct data is important in **data preprocessing**. For example, a camera catching speeding cars will only select cars going above a certain speed.

After selection, background information will be removed so only the numberplate is added to the database.

<br>

## SQL
SQL Command | Description
------------ | -------------
```SELECT```, ```FROM```, ```WHERE``` | User can ```SELECT``` a field ```FROM``` a database ```WHERE``` the field meets a specified value.
```ORDER BY``` | If a user wants to change the order of a field, they can ```ORDER BY``` ascending or descending order.
```CREATE``` | Allows a user to ```CREATE``` a new database.
```ALTER``` | Used to add, delete, or modify the fields in a table, using ```ADD```, ```DROP```, or ```MODIFY```.
```INSERT INTO``` | Used to insert a new record into a database table.
```UPDATE``` | The user can update a record in a table by changing the values in specified fields: <br> ```UPDATE TableName``` <br> ```SET columnX = valueX``` <br> ```WHERE ColumnY = valueY```.
```DELETE``` | Used to delete a record from a table.

<br>

Data Type | Description
------------ | -------------
```CHAR(ùë•)``` | User can input a string of fixed length ùë•
```VARCHAR(ùë•)``` | User can input a string of max length ùë•
```BOOLEAN``` | Sets values as True or False
```INT``` | Sets values as an integer
```FLOAT``` | Sets values as a floating point number
```DATE``` | Gives the date is the format DD/MM/YY
```TIME``` | Gives the time is the format HH/MM/SS
```CURRENCY``` | Sets the number as a monetary amount

<br>

## Referential Integrity
If there is a relationship between two tables, **referential integrity** ensures that no entities or attributes can be deleted from either.

ACID ensures that referential integrity is maintained under all circumstances, and guarantees that transactions are processed properly.

ACID stands for **A**tomicity, **C**onsistency, **I**solation and **D**urability.

### Atomicity
**Atomicity** requires that a transaction should be processed properly or not at all. Even in situations such as power cuts, it's not possible to process only part of a transaction.

### Consistency
**Consistency** ensures that referential integrity is maintained in a database. If two tables are dependant on each other, no entities or attributes can be deleted from either.

### Isolation
**Isolation** ensures that a transaction in process must remain isolated from any other transaction.

### Durability
**Durability** ensures that once a transaction has been committed, it will remain so, even in the event of a power cut. 

Durability can be achieved through **changelogs** that track when the databases are modified. After the event, the changelog will hold data on the most recent transactions in process, and the database can build up back to its original state.















<br>

## Types of Validation

- **Format Check** - Makes sure the data inserted into the field matches the right format     <br>
  Example: If you were to input your age, a format check would make sure it was an integer, not a string

- **Length Check** - Checks the data to see if it fits the field input length   <br>
  Example: A telephone number that can only be 11 digits
  
- **Presence Check** - Checks that a field has not been left blank in a database    <br>
  Example: If there is no data inputted into a field in a database, it‚Äôs common that an alert will pop up telling you not to leave it blank
  
- **Range Check** - Checks that the number inputted is within the specified range     <br>
  Example: Age must be between 0 and 120

- **Spell Check** - Compares your inputted words to those of the dictionary and if they don‚Äôt match, it pops up with an error     <br>
  Example: In applications such as Microsoft Word or other word processors.

<br>

  
## SQL
  
Data Type | Description
------------ | -------------
CHAR(ùë•) | Allows the user to input a string of fixed length ùë•
VARCHAR(ùë•) | Allows the user to input a string of max length ùë•

<br>


## Normalisation and Relational Databases

### Normalisation
- Normalisation is a process used to come up with the best possible design for a database.
- Tables should be organised so that data is not duplicated in the same table or in different tables.
- The structure should allow complex queries to be made.
- There are three stages in normalisation, called First Normal Form (1NF), Second Normal Form (2NF) and Third Normal Form (3NF).

#### First Normal Form (1NF)
- A table is in 1NF if it contains no repeating attributes or groups of attributes.
- All attributes must be **atomic**, meaning a single attribute can't contain two data items, such as firstname and surname. This would make it difficult to sort on the surname.

#### Second Normal Form (2NF)
- A table is in 2NF if it is in !NF and contains no partial dependencies.
- This can only occur if the primary key is a **composite key**.

#### Third Normal Form (3NF)
- A table is in 3NF if it is in 2NF and contains no non-key dependacies.
- Third Normal Form can be defined by saying:
> The attributes are dependant on the key, the whole key, and nothing but the key.

<br>

## Data Capture

### Automated methods

Automated data capture is useful in taking in large amounts of data that is easy to input. Some methods include:
- Smart card readers
- Barcode readers
- Scanners
- Optical character recognition (OCR)
- Optical mark recognition (OMR)
- Magnetic ink character recognition
- Sensors

<br>

## ACID

ACID stands for **A**tomicity, **C**onsistency, **I**solation and **D**urability.

This is a set of properties to ensure that the integrity of the database is maintained under all circumstances. It guarantees that transactions are processed properly.

### Atomicity

Atomicity requires that a transaction should be processed properly or not at all.
In any situation, including power cuts or suchlike, it's not possible to process only part of a transaction.

### Consistency

Consistency ensures that no transaction can violate any of the defined validation rules.

### Isolation

Isolation ensures that the simultaneous execution of transaction leads to the same result, as if transactions were proccessed one after the other.
This is crucial in a multi-user database.

### Durability

Durability ensures that once a transaction has been committed, it will remain so, even in the event of a power cut.
As each part of a transaction is completed, the data is held in a buffer until all elements of the transactions are completed.

<br>

## Referential Integrity

- A primary key is a key that uniquely indentifies the values in a table.
- A foreign key is a primary key from another table.
- A composite key is the same primary key across two tables.

Refers to the relationship between tables. In a relational database, different tables might share the same primary key because it relates to the data in those separate tables. Referential integrity is the dependency of a foreign key on a primary key.
